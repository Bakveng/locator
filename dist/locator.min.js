angular.module('locator', []);
angular.module('locator')
.factory('location', [
  function() {

    var service = {
      isReady: false,
      gpsAvailable: true
    };

    var readyCallbacks = [];

    // Get Current Location
    service.get = function(s_cb, e_cb) {

      // Request location from the navigator service
      navigator.geolocation.getCurrentPosition(function(location) {
        // Geolocation is available
        service.gpsAvailable = true;

        // parse current location
        service.current = {
          latitude: location.coords.latitude,
          longitude: location.coords.longitude
        };

        // Location is ready
        service.isReady = true;
        // Execute the on ready tasks
        service.onReadyTasks();
        // success callback
        s_cb();

      }, function(error) {
        service.gpsAvailable = false;
        console.log('code: ' + error.code + ' message: ' + error.message);
        // error callback
        e_cb();
      });
    };

    // Execute registered tasks
    service.onReadyTasks = function() {
      for (var i = readyCallbacks.length - 1; i >= 0; i--) {
        readyCallbacks[i]();
      };
    };

    // Execute registered tasks if ready
    // or register tasks if not ready yet
    service.ready = function(callback) {
      if (service.isReady) {
        callback();
      } else {
        // If not ready yet, add it to this array
        // which will be called once location is ready
        readyCallbacks.push(callback);
      }
    };

    return service;
  }
]);
angular.module('locator')
  .factory('reverseGeocoder', [
    '$document',
    '$q',
  function($document, $q) {

    var service = {};

    $document.ready(function() {
      service.geocoder = new google.maps.Geocoder();
    });

    service.geocode = function(location) {
      var deferred = $q.defer();

      if (!location) {

        deferred.reject('You need to provide LatLng');

      } else {

        var latlng = new google.maps.LatLng(location.latitude, location.longitude);
      }


      // geocode
      service.geocoder.geocode({
        latLng: latlng
      }, function(results, status) {
        if (status !== google.maps.GeocoderStatus.OK) {

          deferred.reject('No locations found');
          return;

        } else {

          deferred.resolve(results);
        }
      });

      return deferred.promise;
    };

    return service;
  }
]);
angular.module('locator')
  .directive('locationPicker', [
    '$log',
    'location',
    'reverseGeocoder',
  function($log, location, reverseGeocoder) {
    return {
      restrict: 'E',
      require: '?ngModel',
      scope: {},
      templateUrl: 'location-picker/directives/location-picker.html',
      link: function(scope, iElement, iAttrs, model) {

        scope.limitTo = scope.$eval(iAttrs.limitTo) || 15;

        // Get options
        location.ready(function() {
          reverseGeocoder.geocode(location.current)
            .then(function(results) {
              scope.options = results;
            }, $log.error);
        });

        // Pick A Option
        scope.pickLocation = function(locData) {

          var locData = {
            latitude: location.current.latitude,
            longitude: location.current.longitude,
            name: locData.address_components[0].short_name,
            description: locData.formatted_address
          };

          // Update model
          model.$setViewValue(locData);
        };
      }
    }
  }
]);
angular.module('locator')
  .directive('locationLookup', [
  function() {
    return {
      restrict: 'E',
      require: '?ngModel',
      templateUrl: 'location-lookup/directives/location-lookup.html',
      scope: {},
      link: function(scope, iElement, iAttrs, model) {

        scope.limitTo = scope.$eval(iAttrs.limitTo) || 15;
        scope.callback = scope.$eval(iAttrs.callback);
        scope.results = [];
        scope.selectedPlace = '';
        scope.showResult = false;

        scope.$watch('results', function(results){
          if(results && results.length > 0){        
            scope.showResult = true;
          }
        });

        // Generate a DOM elment for Google Places Service
        var elem = document.createElement('div');
            elem.setAttribute('id', scope.ID);

        // Setup Google Places Service
        var googlePlacesService = new google.maps.places.PlacesService(iElement[0].appendChild(elem));

        // Setup Google Auto-complete Service
        var googleMapsService = new google.maps.places.AutocompleteService();        
        var searchInputElement = angular.element(iElement.find('input'));

        // Fetch predictions based on query
        var fetch = function(query) {
          googleMapsService.getPlacePredictions({
            input: query,
            componentRestrictions: {
              country: 'kh'
            }
          }, fetchCallback);
        };

        // Display predictions to the user
        var fetchCallback = function(predictions, status) {

          if (status !== google.maps.places.PlacesServiceStatus.OK) {

            scope.$apply(function() {
              scope.results = [];
            })

            return;

          } else {

            scope.$apply(function() {
              scope.results = predictions;
            })
          }
        };


        // Refresh on every edit
        searchInputElement.on('input', function() {
          var query = searchInputElement.val();

          if (query && query.length >= 3) {

            fetch(query);

          } else {

            scope.$apply(function() {
              scope.results = [];
            });
          }
        });


        // Clear query and results
        scope.clear = function() {
          scope.results = [];
        };

        // Pick A Location
        scope.pickLocation = function(location) {

          // Get details for the selected location
          googlePlacesService.getDetails({
            reference: location.reference
          }, function(place, status) {

            scope.$apply(function() {

              searchInputElement.val(location.description);
              scope.showResult = false;

              var locData = {
                name: location.terms[0].value,
                description: location.description,
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng()
              };

              // Update model
              model.$setViewValue(locData);
              // Callback
              scope.callback && scope.callback(locData);
            });
          });
        };
      }
    }
  }
]);
angular.module('locator')
  .directive('locationPredictions', [
  function() {
    return {
      restrict: 'E',
      scope: { 
        results: '='
      },
      template: '<input type="text" placeholder="search for a location">',
      link: function(scope, iElement, iAttrs) {

        // Setup Google Auto-complete Service
        var googleMapsService = new google.maps.places.AutocompleteService();        
        var el = angular.element(iElement.find('input'));

        // Fetch predictions based on query
        var fetch = function(query) {
          googleMapsService.getPlacePredictions({
            input: query,
            componentRestrictions: {
              country: 'kh'
            }
          }, fetchCallback);
        };

        // Display predictions to the user
        var fetchCallback = function(predictions, status) {

          if (status !== google.maps.places.PlacesServiceStatus.OK) {

            scope.$apply(function() {
              scope.results = [];
            })

            return;

          } else {

            scope.$apply(function() {
              scope.results = predictions;
            })
          }
        };


        // Refresh on every edit
        el.on('input', function() {
          var query = el.val();

          if (query && query.length >= 3) {

            fetch(query);

          } else {

            scope.$apply(function() {
              scope.results = [];
            });
          }
        });

      }
    }
  }
]);

